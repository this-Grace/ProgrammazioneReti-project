\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{enumitem}

\usepackage[italian]{babel}
\usepackage[italian]{cleveref}

% Configurazione listing
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    showstringspaces=false,
    autogobble=true,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt
}

\title{Elaborato per il corso \\ \textit{Programmazione di Reti}}
\author{Grazia Bochdanovits de Kavna}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduzione}

Il presente progetto ha l'obiettivo di realizzare un \textbf{web server HTTP} in \textbf{Python}, realizzato utilizzando socket per gestire le connessioni di rete. 
Il server è progettato per rispondere sulla \textbf{porta 8080} di \texttt{localhost} e servire contenuti statici dalla directory \texttt{www/}.

Il lavoro implementa tutti i requisiti minimi richiesti dalla traccia: gestione delle richieste \texttt{GET} con risposta 200, servizio di almeno tre pagine HTML statiche, e corretta gestione degli errori 404 per file inesistenti. 

Sono state inoltre implementate le estensioni opzionali previste, tra cui il supporto per \textit{MIME types} (HTML, CSS), il logging delle richieste con \textit{timestamp}, e un layout responsive con animazioni CSS.

Il server utilizza \textbf{multithreading} per gestire connessioni concorrenti e include misure di sicurezza per prevenire attacchi di directory traversal. 
Il progetto comprende anche pagine di errore personalizzate (\texttt{404.html}, \texttt{501.html}) e un design moderno.

\chapter{Architettura del progetto}

L'architettura del progetto si basa su una chiara separazione tra la logica applicativa del server e i contenuti statici destinati al client. 
Il sistema è organizzato nei seguenti componenti principali:

\begin{itemize}
    \item \textbf{server.py}: implementa il web server HTTP multithread, in ascolto sulla porta 8080, responsabile della gestione delle connessioni e del servizio dei file statici.
    \item \textbf{www/}: directory contenente il sito web statico, composto da cinque pagine HTML e un file CSS condiviso, con layout responsive e design moderno.
\end{itemize}

\chapter{Implementazione del web server}
\section{Struttura generale}

Il web server è stato implementato in Python utilizzando esclusivamente moduli della standard library. L'architettura segue il pattern classico dei server HTTP multi-threading, dove ogni connessione client viene gestita da un thread separato. La classe principale \texttt{HTTPServer} incapsula tutta la logica del server.

La struttura del codice è organizzata nei seguenti componenti principali:

\begin{itemize}
    \item \textbf{Classe HTTPServer}: Classe principale che gestisce l'intero ciclo di vita del server
    \item \textbf{Gestione delle connessioni}: Accettazione delle connessioni e creazione di thread dedicati
    \item \textbf{Parsing delle richieste}: Analisi degli header HTTP e estrazione dei parametri
    \item \textbf{Resolving dei path}: Conversione sicura degli URL in percorsi del filesystem
    \item \textbf{Servizio dei file}: Gestione dei file statici con controllo dei permessi
    \item \textbf{Gestione degli errori}: Produzione di pagine di errore appropriate
\end{itemize}

\section{Gestione delle richieste}

Il processo di gestione delle richieste segue un flusso ben definito:

\subsection{Accettazione delle connessioni}
Il server rimane in attesa su una socket configurata con opzioni di riutilizzo dell'indirizzo. Quando una connessione viene accettata, viene creato un nuovo thread che gestirà il client fino al completamento della richiesta.

\begin{lstlisting}
def _run_server_loop(self):
    self.running = True
    while self.running:
        try:
            client_socket, client_address = self.socket.accept()
            thread = threading.Thread(
                target=self._handle_client, 
                args=(client_socket, client_address),
                daemon=True
            )
            thread.start()
        except socket.timeout:
            continue
        except KeyboardInterrupt:
            self.logger.info("Shutting down...")
            break
        except Exception as e:
            if self.running:
                self.logger.error(f"Accept error: {e}")
            break
\end{lstlisting}

\subsection{Parsing della richiesta}
La richiesta HTTP viene analizzata estraendo il metodo, il path e la versione del protocollo. Sono supportati esclusivamente richieste GET secondo lo standard HTTP/1.x.

\begin{lstlisting}
def _process_request(self, client_socket, request_data):
    lines = request_data.split('\n')
    if not lines or not lines[0].strip():
        return self._send_error(client_socket, 400)
        
    parts = lines[0].strip().split()
    if len(parts) != 3:
        return self._send_error(client_socket, 400)
        
    method, path, version = parts
    if method != 'GET':
        return self._send_error(client_socket, 405)
    if not version.startswith('HTTP/1.'):
        return self._send_error(client_socket, 400)
        
    self._handle_get(client_socket, path)
\end{lstlisting}

\subsection{Resolving del percorso}
Il path richiesto viene normalizzato e convertito in un percorso del filesystem locale, con controlli di sicurezza per prevenire directory traversal attacks.

\begin{lstlisting}
def _resolve_path(self, url_path):
    try:
        path = unquote(urlparse(url_path).path)
        path = os.path.normpath(path)
        
        if path in ('/', '.'):
            path = '/home.html'
        if path.startswith('/'):
            path = path[1:]
            
        full_path = os.path.join(self.www_dir, path)
        
        # Security check
        if os.path.abspath(full_path).startswith(self.www_dir):
            return full_path
            
    except Exception as e:
        self.logger.warning(f"Path resolution error: {e}")
    return None
\end{lstlisting}

\subsection{Servizio dei file}
I file vengono serviti con il corretto Content-Type determinato automaticamente. Sono implementati controlli per:
\begin{itemize}
    \item Dimensioni massime dei file (10MB)
    \item Tipi di file supportati (esclusi .php, .jsp, .asp)
    \item Gestione automatica di index.html per le directory
    \item Pagine di errore personalizzabili
\end{itemize}

\begin{lstlisting}
def _serve_file(self, client_socket, file_path):
    try:
        # Size limit check
        if os.path.getsize(file_path) > 10 * 1024 * 1024:
            return self._send_error(client_socket, 413)
            
        with open(file_path, 'rb') as f:
            content = f.read()
            
        mime_type = mimetypes.guess_type(file_path)[0] or 'application/octet-stream'
        self._send_response(client_socket, 200, content, mime_type)
        
    except FileNotFoundError:
        self._send_error(client_socket, 404)
    except PermissionError:
        self._send_error(client_socket, 403)
    except Exception as e:
        self.logger.error(f"File serve error: {e}")
        self._send_error(client_socket, 500)
\end{lstlisting}

\subsection{Gestione degli errori}
Il server produce pagine di errore appropriate per i vari codici di stato HTTP. Sono supportate sia pagine personalizzate (es. 404.html) che pagine di default generate dinamicamente.

\begin{lstlisting}
def _get_error_content(self, status_code):
    # Try custom error page first
    error_file = os.path.join(self.www_dir, f"{status_code}.html")
    if os.path.isfile(error_file):
        try:
            with open(error_file, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception:
            pass
    
    # Default error page
    status_text = self.STATUS_CODES.get(status_code, "Error")
    return f"""<!DOCTYPE html>
        <html><head><title>{status_code} {status_text}</title></head>
        <body style="font-family:Arial;text-align:center;margin-top:100px;">
        <h1 style="color:#e74c3c;">{status_code}</h1>
        <h2>{status_text}</h2>
        <p>La risorsa richiesta non è disponibile.</p>
        <a href="/" style="color:#3498db;">Torna alla homepage</a>
        </body></html>"""
\end{lstlisting}

\subsection{Logging}
Tutte le attività del server vengono registrate sia su file che su console, includendo timestamp, indirizzi IP client e richieste effettuate.

\begin{lstlisting}
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.FileHandler('server.log'), logging.StreamHandler()]
)
\end{lstlisting}

Questa implementazione garantisce un server stabile, sicuro e conforme agli standard HTTP di base, adatto per servire contenuti statici in ambienti didattici e di testing.

\chapter{Sito web statico}

Il sito web è composto da cinque pagine HTML statiche, tutte stilizzate mediante un unico file CSS condiviso (\texttt{common.css}).

\section{Pagine HTML}

\begin{itemize}
    \item \textbf{home.html}: Homepage del sito con navigazione principale
    \item \textbf{login.html}: Pagina di autenticazione con form per le credenziali
    \item \textbf{contact.html}: Pagina di contatto con informazioni e form
    \item \textbf{404.html}: Pagina di errore personalizzata per risorse non trovate
    \item \textbf{501.html}: Pagina per funzionalità non ancora implementate
\end{itemize}

\chapter{Conclusioni}

Il server sviluppato in Python soddisfa pienamente i requisiti della traccia, rispondendo su \texttt{localhost:8080}, gestendo correttamente richieste GET e fornendo pagine di errore personalizzate. 
Sono state realizzate tutte le estensioni opzionali, includendo la gestione dei MIME type, il logging delle richieste e un sito statico con layout responsive. 

\section{Sviluppi Futuri}

Il progetto, pur essendo completo e funzionale, può essere esteso con diverse funzionalità avanzate come il supporto HTTPS per comunicazioni cifrate e l'implementazione di metodi HTTP aggiuntivi come POST per gestire l'invio di dati dai form. Queste estensioni renderebbero il server più versatile e adatto ad applicazioni reali.

\appendix
\chapter{Guida utente}

\section{Installazione e Avvio}

\begin{enumerate}
    \item \textbf{Clonazione del repository}:\\
    \texttt{git clone https://github.com/this-Grace/ProgrammazioneReti-project.git}

    \item \textbf{Accesso alla directory}:\\
    \texttt{cd ProgrammazioneReti-project}

    \item \textbf{Avvio del server}:\\
    \texttt{python server.py}

    \item \textbf{Accesso al sito}:\\
    Aprire un browser e navigare su \texttt{http://localhost:8080}
\end{enumerate}

\section{Accesso alle pagine}

\begin{itemize}
    \item \textbf{Homepage}: \url{http://localhost:8080/}
    \item \textbf{Pagina di login}: \url{http://localhost:8080/login.html}
    \item \textbf{Pagina di contatti}: \url{http://localhost:8080/contact.html}
    \item \textbf{Pagina 404}: \url{http://localhost:8080/404.html}
    \item \textbf{Pagina 501}: \url{http://localhost:8080/501.html}
\end{itemize}

\subsection{Note sull'accesso}

\begin{itemize}
    \item La root \texttt{/} restituisce automaticamente \texttt{home.html}.
    \item File non esistenti mostrano la pagina \texttt{404.html}.
    \item Il form di login reindirizza a \texttt{501.html}.
\end{itemize}

\section{Arresto del Server}

\begin{itemize}
    \item Premere \texttt{Ctrl+C} nel terminale.
    \item Attendere la chiusura delle connessioni.
    \item Verificare il messaggio: \texttt{Server stopped.}
\end{itemize}

\end{document}
