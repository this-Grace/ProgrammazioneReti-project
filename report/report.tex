\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{lstautogobble}

\usepackage[italian]{babel}
\usepackage[italian]{cleveref}

\title{Elaborato per il corso \\ \textit{Programmazione di Reti}}
\author{Grazia Bochdanovits de Kavna}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduzione}

Il presente progetto ha l'obiettivo di realizzare un \textbf{web server HTTP} in \textbf{Python}, realizzato utilizzando socket per gestire le connessioni di rete. 
Il server è progettato per rispondere sulla \textbf{porta 8080} di \texttt{localhost} e servire contenuti statici dalla directory \texttt{www/}.

Il lavoro implementa tutti i requisiti minimi richiesti dalla traccia: gestione delle richieste \texttt{GET} con risposta 200, servizio di almeno tre pagine HTML statiche (\texttt{index.html}, \texttt{login.html}, \texttt{contact.html}), e corretta gestione degli errori 404 per file inesistenti. 

Sono state inoltre implementate le estensioni opzionali previste, tra cui il supporto per \textit{MIME types} (HTML, CSS), il logging delle richieste con \textit{timestamp}, e un layout responsive con animazioni CSS.

Il server utilizza \textbf{multithreading} per gestire connessioni concorrenti e include misure di sicurezza per prevenire attacchi di directory traversal. 
Il progetto comprende anche pagine di errore personalizzate (\texttt{404.html}, \texttt{501.html}) e un design moderno.

\chapter{Architettura del progetto}

L'architettura del progetto si basa su una chiara separazione tra la logica applicativa del server e i contenuti statici destinati al client. 
Il sistema è organizzato nei seguenti componenti principali:

\begin{itemize}
    \item \textbf{server.py}: implementa il web server HTTP multithread, in ascolto sulla porta 8080, responsabile della gestione delle connessioni e del servizio dei file statici.
    \item \textbf{www/}: directory contenente il sito web statico, composto da cinque pagine HTML e un file CSS condiviso, con layout responsive e design moderno.
\end{itemize}

\chapter{Implementazione del web server}

\section{Struttura generale}

L'implementazione del web server è stata realizzata attraverso una classe Python \texttt{HTTPServer} che incapsula tutte le funzionalità necessarie per servire contenuti statici via HTTP. 
La struttura del server segue un approccio object-oriented che favorisce modularità e manutenibilità del codice.

\subsection{Architettura della classe \texttt{HTTPServer}}

La classe principale \texttt{HTTPServer} è organizzata in componenti specifici, ognuno implementato attraverso metodi dedicati:

\begin{itemize}
    \item \textbf{Configurazione iniziale}: I metodi \texttt{\_\_init\_\_} e \texttt{\_initialize\_mime\_types} gestiscono l'inizializzazione del server e la configurazione dei tipi MIME supportati.
    \item \textbf{Gestione socket}: I metodi \texttt{\_setup\_socket}, \texttt{\_bind\_and\_listen} e \texttt{\_cleanup} si occupano della configurazione e gestione del socket di rete durante tutto il ciclo di vita del server.
    \item \textbf{Elaborazione richieste}: I metodi \texttt{handle\_client}, \texttt{\_process\_request} e \texttt{handle\_get\_request} implementano il parsing e il processamento delle richieste HTTP.
    \item \textbf{Generazione risposte}: I metodi \texttt{serve\_file}, \texttt{send\_error}, \texttt{\_build\_response\_headers} e \texttt{\_send\_response} costruiscono e inviano le risposte HTTP appropriate.
    \item \textbf{Gestione concorrenza}: I metodi \texttt{\_handle\_client\_in\_thread} e il main loop \texttt{\_run\_server\_loop} gestiscono le connessioni concorrenti attraverso thread separati.
    \item \textbf{Controlli sicurezza}: I metodi \texttt{\_resolve\_file\_path} e \texttt{\_is\_safe\_path} implementano i controlli di sicurezza per prevenire accessi non autorizzati al filesystem.
    \item \textbf{Utility}: Metodi di supporto come \texttt{log\_request}, \texttt{\_read\_file\_content}, \texttt{\_get\_mime\_type} forniscono funzionalità ausiliarie.
\end{itemize}

\subsection{Ciclo di vita del Server}

Il server opera secondo un ciclo di vita ben definito:

\begin{enumerate}
    \item \textbf{Inizializzazione}: Configurazione parametri e mappatura MIME types attraverso \texttt{\_\_init\_\_} e \texttt{\_initialize\_mime\_types}.
    \item \textbf{Startup}: Creazione socket e binding all'indirizzo specificato tramite \texttt{\_setup\_socket} e \texttt{\_bind\_and\_listen}.
    \item \textbf{Main loop}: Accettazione connessioni client nel metodo \texttt{\_run\_server\_loop}, con delega a \texttt{\_handle\_client\_in\_thread} per la gestione in thread separati.
    \item \textbf{Shutdown}: Chiusura ordinata delle risorse attraverso \texttt{stop} e \texttt{\_cleanup}.
\end{enumerate}

\section{Gestione delle richieste}

\subsection{Validazione dei metodi HTTP}

Il server implementa una whitelist approach, accettando esclusivamente richieste GET per garantire sicurezza e semplicità:

\begin{lstlisting}[language=Python]
if method != 'GET':
    self.send_error(client_socket, 405, "Method Not Allowed")
    return
\end{lstlisting}

\subsection{Risoluzione dei path}

La risoluzione dei path URL avviene attraverso un processo di parsing e normalizzazione che include controlli di sicurezza per prevenire directory traversal attacks:

\begin{lstlisting}[language=Python]
def _resolve_file_path(self, url_path: str) -> Optional[str]:
    parsed_path = urlparse(url_path)
    path = unquote(parsed_path.path)
    # ... normalizzazione e controlli di sicurezza
\end{lstlisting}

\subsection{Threading e concorrenza}

Ogni richiesta client viene gestita in un thread separato, permettendo al server di servire multiple connessioni simultaneamente:

\begin{lstlisting}[language=Python]
thread = threading.Thread(
    target=self.handle_client,
    args=(client_socket, client_address)
)
thread.daemon = True
thread.start()
\end{lstlisting}

\section{Gestione MIME types e logging}

\subsubsection{Headers HTTP}

La generazione degli headers HTTP segue lo standard HTTP/1.1, includendo tutti i campi necessari per una corretta comunicazione client-server:

\begin{lstlisting}[language=Python]
def _build_response_headers(self, status_code: int, status_text: str,
                            content_type: str, content_length: int) -> list:
    return [
        f"HTTP/1.1 {status_code} {status_text}",
        f"Content-Type: {content_type}",
        f"Content-Length: {content_length}",
        "Connection: close",
        "\r\n"
    ]
\end{lstlisting}

\subsubsection{Sistema di logging}

Il sistema di logging registra timestamp, indirizzo client e dettagli della richiesta, fornendo visibilità completa sull'attività del server:

\begin{lstlisting}[language=Python]
def log_request(self, client_address: Tuple[str, int], request: str) -> None:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    request_line = request.split('\n')[0].strip() if request else "Invalid request"
    print(f"[{timestamp}] {client_address[0]}:{client_address[1]} - {request_line}")
\end{lstlisting}

\section{Sicurezza base}

\subsection{Prevenzione directory traversal}

Il controllo di sicurezza verifica che il path richiesto sia contenuto entro la directory autorizzata, prevenendo accessi a file sensibili del sistema:

\begin{lstlisting}[language=Python]
def _is_safe_path(self, path: str) -> bool:
    requested_path = os.path.abspath(path)
    return requested_path.startswith(self.www_dir)
\end{lstlisting}

\subsection{Gestione degli errori HTTP}

Il server implementa una gestione completa degli errori HTTP con codici di stato appropriati e pagine personalizzate per migliorare l'esperienza utente.

\subsection{Resource cleanup}

Il sistema di cleanup garantisce il corretto rilascio delle risorse di rete e la chiusura ordinata di tutte le connessioni.

\chapter{Sito web statico}

Il sito web è composto da cinque pagine HTML statiche, tutte stilizzate mediante un unico file CSS condiviso (\texttt{common.css}).

\section{Pagine HTML}

\begin{itemize}
    \item \textbf{index.html}: Homepage del sito con navigazione principale
    \item \textbf{login.html}: Pagina di autenticazione con form per le credenziali
    \item \textbf{contact.html}: Pagina di contatto con informazioni e form
    \item \textbf{404.html}: Pagina di errore personalizzata per risorse non trovate
    \item \textbf{501.html}: Pagina per funzionalità non ancora implementate
\end{itemize}

\chapter{Conclusioni}

Il server sviluppato in Python soddisfa pienamente i requisiti della traccia, rispondendo su \texttt{localhost:8080}, gestendo correttamente richieste GET e fornendo pagine di errore personalizzate. 
Sono state realizzate tutte le estensioni opzionali, includendo la gestione dei MIME type, il logging delle richieste e un sito statico con layout responsive. 
Il server rappresenta una soluzione ben strutturata che supera i requisiti minimi previsti.

\section{Sviluppi Futuri}

Il progetto, pur essendo completo e funzionale, può essere esteso con diverse funzionalità avanzate come il supporto HTTPS per comunicazioni cifrate e l'implementazione di metodi HTTP aggiuntivi come POST per gestire l'invio di dati dai form. Queste estensioni renderebbero il server più versatile e adatto ad applicazioni reali.

\appendix
\chapter{Guida utente}

\section{Installazione e Avvio}

\begin{enumerate}
    \item \textbf{Clonazione del repository}:\\
    \texttt{git clone https://github.com/this-Grace/ProgrammazioneReti-project.git}

    \item \textbf{Accesso alla directory}:\\
    \texttt{cd ProgrammazioneReti-project}

    \item \textbf{Avvio del server}:\\
    \texttt{python3 server.py}

    \item \textbf{Accesso al sito}:\\
    Aprire un browser e navigare su \texttt{http://localhost:8080}
\end{enumerate}

\section{Accesso alle pagines}

\begin{itemize}
    \item \textbf{Homepage}: \url{http://localhost:8080/}
    \item \textbf{Pagina di login}: \url{http://localhost:8080/login.html}
    \item \textbf{Pagina di contatti}: \url{http://localhost:8080/contact.html}
    \item \textbf{Pagina 404}: \url{http://localhost:8080/404.html}
    \item \textbf{Pagina 501}: \url{http://localhost:8080/501.html}
\end{itemize}

\subsection{Note sull'accesso}

\begin{itemize}
    \item La root \texttt{/} restituisce automaticamente \texttt{index.html}.
    \item File non esistenti mostrano la pagina \texttt{404.html}.
    \item Il form di login reindirizza a \texttt{501.html}.
\end{itemize}

\section{Arresto del Server}

\begin{itemize}
    \item Premere \texttt{Ctrl+C} nel terminale.
    \item Attendere la chiusura delle connessioni.
    \item Verificare il messaggio: \texttt{Server stopped.}
\end{itemize}

\end{document}
